---
title: 程设大作业之魔兽世界3：开战
date: 2018-11-13 21:55:34
tags: 
    - 程序设计
    - 面向对象
    - 随笔
mathjax: true
---

[程序设计与算法](https://www.icourse163.org/learn/PKU-1002029030?tid=1003186012#/learn/forumindex)这个课终于完结啦\~\~\~撒花\~\~\~\~

　　上周公布了大作业，就是下面这个：
[OpenJudge - 1:魔兽世界三(开战)](http://cxsjsxmooc.openjudge.cn/2018t3fallwar/1/)


　　虽然有前面的一和二打底，但我看到这个题目还是虎躯一震，作为大学只学过C语言的，从来没有写过代码需求量这么大的题呀。

　　但还是咬咬牙坚持下来了，写完后才觉得好像也没那么难，但我毕竟是新手，所以惭愧地说还是花了好几天时间，甚至好几天晚上debug到三点多还浑然不知意犹未尽，直到最终可爱的蓝色的**ACCEPT**，才觉得吐出一口浊气，浑身清爽。

　　最终的代码量（包括有些调试语句没有完全删掉）有760行，真正写的时候发现和一和二还是差别挺大，所以干脆重写了。用的语言是C++，本来想把课上讲的各种fancy的功能一股脑用上，后来发现有的还是没必要都删了，比如多态，而且最开始调试的时候乱得都不知道错误出在哪，不过如果写了的话后期改功能和维护会方便点吧。

　　首先讲下我的主要思路：

　　定义`warrior`, `tribe`, `fields`四个对象表示武器，武士，部落，和城市。

- `weapon`：种类，剩余使用次数，是否OK等成员变量。
- `warrior`：有个武器库，我用`vector<weapon*>`存储，还设了指向其所在部落的指针，武士编号，种类，是否活着等变量。
- `tribe`：阵营，武士数量，武士库`vector<warrior*)>`，当前所在城市等；
- `fields`：只有两个成员变量，也就是两个指针分别指向该城市中的红武士和蓝武士。

　　因为最终的相同时间点的输出是按照城市编号来进行，所以我干脆设了个全局变量`vector<fields*>` ，存储当前各个城市的信息，这样每次输出一个for循环就搞定了。

　　下面记录下我卡壳比较久的地方吧。

## １.　武士march
　　　这个我开始非常固执和先入为主地觉得，每次march要按fields来，这样每次后面的就会覆盖前面的。怎么办呢？我当时每次march都新建一个新的战场`vector<fields*>`，然后让march的武士移过去，结果因为对指针操作的不熟练，各种出错。

　　后来我上厕所的时候想，为啥不直接按tribe来呢，反正在tribe有所有武士的信息，红的归红的，蓝的归蓝的，让他们自己动，动完再传给fields不久行了么？然后很兴奋，马上坑都不蹲了，跑过去改。

　　果然，结果很好，代码通畅和简洁了不少。这部分代码如下：

```cp
void tribe::tribe_march(int color){
         //清空当前战场信息
    for(int i=0;i<=CITY_NUM+1;i++){
        if(color==0)
            fields_all[i]->wR=NULL;
        else
            fields_all[i]->wB=NULL;
    }
    for(int i=0;i<warr_total;i++){
        warrior *w = own_warriors[i];
        if (w->isalive()) {
            w->march();//march结束状态发生变化的是iceman
            if(w->isalive()){
                int num = w->city_n;
                if(color==0) fields_all[num]->wR = w;
                if(color==1) fields_all[num]->wB = w;
            }
        }
    }
}
```

## ２.　武士battle

　　这个是我当时觉得很难的，所以放到最后才敢写。同样，我开始想得很纠结：

>第一步：先写个打你的attack函数

>第二步：在每个城市，红的和蓝的若是遇到了，就来啊，battle啊

>第三步：遍历整个战场

　　后来发现，这样写有个问题，因为按城市编号不同，先手方不一样，所以我立马想到，这是回合制的啊，那我的attack函数干脆写个round啊，一方打完另一方打。

　　后来发现还是想复杂了，不如:

> 第一步：把一个城市的battle写成一个函数，void warrior:: attack(warrior *enemy)
> 第二步：然后遍历整个战场，按城市编号决定谁先出手


　　再次果然，这么写就清爽通顺了许多。

## ３. Wrong Answer了怎么办

　　当openjudge的报错终于不是RuntimeError的时候，我感觉已经成功一半了，然后看着输出大致是对的呀，为啥就是Wrong Answer呢？然后我开始傻乎乎地去凭肉眼和人力一个一个去比对，动用了以前发现单层材料的眼力劲，看哪里出错了，实在找不出来，还觉得自己挺对。这时候，感谢网络，我找到了解决办法。

　　首先，我们在main函数里加两句从文件接收输入和输出到文件的语句：

```cp
freopen("datapub2.in","r",stdin);
freopen("my_out.out","w",stdout);
```


　　然后用python写个脚本，比较自己输出和标准输出的差别：

```pyth
name_in = "datapub2"
name_out="my_out" 
i=0 #行数
with open(str(name_in) + ".out", "r") as std_ans:
    with open(str(name_out) + ".out", "r") as my_ans:
        for s, t in zip(std_ans, my_ans):
            s = s.rstrip()
            t = t.rstrip()
            i = i+1
            if s != t:
                print()
                print(i,": answer:", s)
                print(i,": my    :", t)
                print()
print("down!")
```

　　然后很容易就找到错在哪啦！

　　比如我觉得自己对得不行的那次就是我对题目中这句话理解有误，把武器的状态理解成了武器的数量，改完果然ac啦~~~
>如果战斗中双方的生命值和武器的状态都不再发生变化，则战斗结束，算平局

## 4.  其他小问题的tips

- **慎用vector的erase()**。之前一直RE，排查了好久才发现是报废武器的时候用的是打完一次性erase的方法，但每次erase后迭代器的状态发生了变化，其实是找不到该erase哪个。我还偏偏很二地用了个遍历所有武器的循环。。。。

- **RE的时候判断是哪一步出了错**。习惯（只会）通过程序中加打印输出的语句判断是哪一步出问题。。。。我开始以为cpp和python一样，打印到哪停止就是哪出了错，后来发现不尽然，因为好几次是我00 min的结果都打印不出来，后来我在各个地方加上调试语句才逐步缩小范围找到是哪出错。

- 还有个乌龙的问题。。。我之前写了个武器排序函数，但发现就是不起作用，编译也没问题，纠结了好久，发现是那句话前面有个return语句没打分号，偏偏这两句话中间还有个被我注释了的调试语句，要不是因为缩进量有点奇怪，实在是好难发现。。。。

